// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"cinema/pkg/ent/migrate"

	"cinema/pkg/ent/cinema"
	"cinema/pkg/ent/movie"
	"cinema/pkg/ent/screening"
	"cinema/pkg/ent/seat"
	"cinema/pkg/ent/seatreservation"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Cinema is the client for interacting with the Cinema builders.
	Cinema *CinemaClient
	// Movie is the client for interacting with the Movie builders.
	Movie *MovieClient
	// Screening is the client for interacting with the Screening builders.
	Screening *ScreeningClient
	// Seat is the client for interacting with the Seat builders.
	Seat *SeatClient
	// SeatReservation is the client for interacting with the SeatReservation builders.
	SeatReservation *SeatReservationClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Cinema = NewCinemaClient(c.config)
	c.Movie = NewMovieClient(c.config)
	c.Screening = NewScreeningClient(c.config)
	c.Seat = NewSeatClient(c.config)
	c.SeatReservation = NewSeatReservationClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:             ctx,
		config:          cfg,
		Cinema:          NewCinemaClient(cfg),
		Movie:           NewMovieClient(cfg),
		Screening:       NewScreeningClient(cfg),
		Seat:            NewSeatClient(cfg),
		SeatReservation: NewSeatReservationClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:             ctx,
		config:          cfg,
		Cinema:          NewCinemaClient(cfg),
		Movie:           NewMovieClient(cfg),
		Screening:       NewScreeningClient(cfg),
		Seat:            NewSeatClient(cfg),
		SeatReservation: NewSeatReservationClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Cinema.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	c.Cinema.Use(hooks...)
	c.Movie.Use(hooks...)
	c.Screening.Use(hooks...)
	c.Seat.Use(hooks...)
	c.SeatReservation.Use(hooks...)
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	c.Cinema.Intercept(interceptors...)
	c.Movie.Intercept(interceptors...)
	c.Screening.Intercept(interceptors...)
	c.Seat.Intercept(interceptors...)
	c.SeatReservation.Intercept(interceptors...)
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *CinemaMutation:
		return c.Cinema.mutate(ctx, m)
	case *MovieMutation:
		return c.Movie.mutate(ctx, m)
	case *ScreeningMutation:
		return c.Screening.mutate(ctx, m)
	case *SeatMutation:
		return c.Seat.mutate(ctx, m)
	case *SeatReservationMutation:
		return c.SeatReservation.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// CinemaClient is a client for the Cinema schema.
type CinemaClient struct {
	config
}

// NewCinemaClient returns a client for the Cinema from the given config.
func NewCinemaClient(c config) *CinemaClient {
	return &CinemaClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `cinema.Hooks(f(g(h())))`.
func (c *CinemaClient) Use(hooks ...Hook) {
	c.hooks.Cinema = append(c.hooks.Cinema, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `cinema.Intercept(f(g(h())))`.
func (c *CinemaClient) Intercept(interceptors ...Interceptor) {
	c.inters.Cinema = append(c.inters.Cinema, interceptors...)
}

// Create returns a builder for creating a Cinema entity.
func (c *CinemaClient) Create() *CinemaCreate {
	mutation := newCinemaMutation(c.config, OpCreate)
	return &CinemaCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Cinema entities.
func (c *CinemaClient) CreateBulk(builders ...*CinemaCreate) *CinemaCreateBulk {
	return &CinemaCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CinemaClient) MapCreateBulk(slice any, setFunc func(*CinemaCreate, int)) *CinemaCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CinemaCreateBulk{err: fmt.Errorf("calling to CinemaClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CinemaCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CinemaCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Cinema.
func (c *CinemaClient) Update() *CinemaUpdate {
	mutation := newCinemaMutation(c.config, OpUpdate)
	return &CinemaUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CinemaClient) UpdateOne(ci *Cinema) *CinemaUpdateOne {
	mutation := newCinemaMutation(c.config, OpUpdateOne, withCinema(ci))
	return &CinemaUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CinemaClient) UpdateOneID(id int64) *CinemaUpdateOne {
	mutation := newCinemaMutation(c.config, OpUpdateOne, withCinemaID(id))
	return &CinemaUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Cinema.
func (c *CinemaClient) Delete() *CinemaDelete {
	mutation := newCinemaMutation(c.config, OpDelete)
	return &CinemaDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CinemaClient) DeleteOne(ci *Cinema) *CinemaDeleteOne {
	return c.DeleteOneID(ci.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CinemaClient) DeleteOneID(id int64) *CinemaDeleteOne {
	builder := c.Delete().Where(cinema.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CinemaDeleteOne{builder}
}

// Query returns a query builder for Cinema.
func (c *CinemaClient) Query() *CinemaQuery {
	return &CinemaQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCinema},
		inters: c.Interceptors(),
	}
}

// Get returns a Cinema entity by its id.
func (c *CinemaClient) Get(ctx context.Context, id int64) (*Cinema, error) {
	return c.Query().Where(cinema.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CinemaClient) GetX(ctx context.Context, id int64) *Cinema {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySeats queries the seats edge of a Cinema.
func (c *CinemaClient) QuerySeats(ci *Cinema) *SeatQuery {
	query := (&SeatClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ci.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(cinema.Table, cinema.FieldID, id),
			sqlgraph.To(seat.Table, seat.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, cinema.SeatsTable, cinema.SeatsColumn),
		)
		fromV = sqlgraph.Neighbors(ci.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryScreenings queries the screenings edge of a Cinema.
func (c *CinemaClient) QueryScreenings(ci *Cinema) *ScreeningQuery {
	query := (&ScreeningClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ci.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(cinema.Table, cinema.FieldID, id),
			sqlgraph.To(screening.Table, screening.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, cinema.ScreeningsTable, cinema.ScreeningsColumn),
		)
		fromV = sqlgraph.Neighbors(ci.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CinemaClient) Hooks() []Hook {
	return c.hooks.Cinema
}

// Interceptors returns the client interceptors.
func (c *CinemaClient) Interceptors() []Interceptor {
	return c.inters.Cinema
}

func (c *CinemaClient) mutate(ctx context.Context, m *CinemaMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CinemaCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CinemaUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CinemaUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CinemaDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Cinema mutation op: %q", m.Op())
	}
}

// MovieClient is a client for the Movie schema.
type MovieClient struct {
	config
}

// NewMovieClient returns a client for the Movie from the given config.
func NewMovieClient(c config) *MovieClient {
	return &MovieClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `movie.Hooks(f(g(h())))`.
func (c *MovieClient) Use(hooks ...Hook) {
	c.hooks.Movie = append(c.hooks.Movie, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `movie.Intercept(f(g(h())))`.
func (c *MovieClient) Intercept(interceptors ...Interceptor) {
	c.inters.Movie = append(c.inters.Movie, interceptors...)
}

// Create returns a builder for creating a Movie entity.
func (c *MovieClient) Create() *MovieCreate {
	mutation := newMovieMutation(c.config, OpCreate)
	return &MovieCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Movie entities.
func (c *MovieClient) CreateBulk(builders ...*MovieCreate) *MovieCreateBulk {
	return &MovieCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MovieClient) MapCreateBulk(slice any, setFunc func(*MovieCreate, int)) *MovieCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MovieCreateBulk{err: fmt.Errorf("calling to MovieClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MovieCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MovieCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Movie.
func (c *MovieClient) Update() *MovieUpdate {
	mutation := newMovieMutation(c.config, OpUpdate)
	return &MovieUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MovieClient) UpdateOne(m *Movie) *MovieUpdateOne {
	mutation := newMovieMutation(c.config, OpUpdateOne, withMovie(m))
	return &MovieUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MovieClient) UpdateOneID(id int64) *MovieUpdateOne {
	mutation := newMovieMutation(c.config, OpUpdateOne, withMovieID(id))
	return &MovieUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Movie.
func (c *MovieClient) Delete() *MovieDelete {
	mutation := newMovieMutation(c.config, OpDelete)
	return &MovieDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MovieClient) DeleteOne(m *Movie) *MovieDeleteOne {
	return c.DeleteOneID(m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MovieClient) DeleteOneID(id int64) *MovieDeleteOne {
	builder := c.Delete().Where(movie.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MovieDeleteOne{builder}
}

// Query returns a query builder for Movie.
func (c *MovieClient) Query() *MovieQuery {
	return &MovieQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMovie},
		inters: c.Interceptors(),
	}
}

// Get returns a Movie entity by its id.
func (c *MovieClient) Get(ctx context.Context, id int64) (*Movie, error) {
	return c.Query().Where(movie.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MovieClient) GetX(ctx context.Context, id int64) *Movie {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryScreenings queries the screenings edge of a Movie.
func (c *MovieClient) QueryScreenings(m *Movie) *ScreeningQuery {
	query := (&ScreeningClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(movie.Table, movie.FieldID, id),
			sqlgraph.To(screening.Table, screening.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, movie.ScreeningsTable, movie.ScreeningsColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MovieClient) Hooks() []Hook {
	return c.hooks.Movie
}

// Interceptors returns the client interceptors.
func (c *MovieClient) Interceptors() []Interceptor {
	return c.inters.Movie
}

func (c *MovieClient) mutate(ctx context.Context, m *MovieMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MovieCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MovieUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MovieUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MovieDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Movie mutation op: %q", m.Op())
	}
}

// ScreeningClient is a client for the Screening schema.
type ScreeningClient struct {
	config
}

// NewScreeningClient returns a client for the Screening from the given config.
func NewScreeningClient(c config) *ScreeningClient {
	return &ScreeningClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `screening.Hooks(f(g(h())))`.
func (c *ScreeningClient) Use(hooks ...Hook) {
	c.hooks.Screening = append(c.hooks.Screening, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `screening.Intercept(f(g(h())))`.
func (c *ScreeningClient) Intercept(interceptors ...Interceptor) {
	c.inters.Screening = append(c.inters.Screening, interceptors...)
}

// Create returns a builder for creating a Screening entity.
func (c *ScreeningClient) Create() *ScreeningCreate {
	mutation := newScreeningMutation(c.config, OpCreate)
	return &ScreeningCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Screening entities.
func (c *ScreeningClient) CreateBulk(builders ...*ScreeningCreate) *ScreeningCreateBulk {
	return &ScreeningCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ScreeningClient) MapCreateBulk(slice any, setFunc func(*ScreeningCreate, int)) *ScreeningCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ScreeningCreateBulk{err: fmt.Errorf("calling to ScreeningClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ScreeningCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ScreeningCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Screening.
func (c *ScreeningClient) Update() *ScreeningUpdate {
	mutation := newScreeningMutation(c.config, OpUpdate)
	return &ScreeningUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ScreeningClient) UpdateOne(s *Screening) *ScreeningUpdateOne {
	mutation := newScreeningMutation(c.config, OpUpdateOne, withScreening(s))
	return &ScreeningUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ScreeningClient) UpdateOneID(id int64) *ScreeningUpdateOne {
	mutation := newScreeningMutation(c.config, OpUpdateOne, withScreeningID(id))
	return &ScreeningUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Screening.
func (c *ScreeningClient) Delete() *ScreeningDelete {
	mutation := newScreeningMutation(c.config, OpDelete)
	return &ScreeningDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ScreeningClient) DeleteOne(s *Screening) *ScreeningDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ScreeningClient) DeleteOneID(id int64) *ScreeningDeleteOne {
	builder := c.Delete().Where(screening.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ScreeningDeleteOne{builder}
}

// Query returns a query builder for Screening.
func (c *ScreeningClient) Query() *ScreeningQuery {
	return &ScreeningQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeScreening},
		inters: c.Interceptors(),
	}
}

// Get returns a Screening entity by its id.
func (c *ScreeningClient) Get(ctx context.Context, id int64) (*Screening, error) {
	return c.Query().Where(screening.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ScreeningClient) GetX(ctx context.Context, id int64) *Screening {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMovie queries the movie edge of a Screening.
func (c *ScreeningClient) QueryMovie(s *Screening) *MovieQuery {
	query := (&MovieClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(screening.Table, screening.FieldID, id),
			sqlgraph.To(movie.Table, movie.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, screening.MovieTable, screening.MovieColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCinema queries the cinema edge of a Screening.
func (c *ScreeningClient) QueryCinema(s *Screening) *CinemaQuery {
	query := (&CinemaClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(screening.Table, screening.FieldID, id),
			sqlgraph.To(cinema.Table, cinema.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, screening.CinemaTable, screening.CinemaColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySeatReservations queries the seat_reservations edge of a Screening.
func (c *ScreeningClient) QuerySeatReservations(s *Screening) *SeatReservationQuery {
	query := (&SeatReservationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(screening.Table, screening.FieldID, id),
			sqlgraph.To(seatreservation.Table, seatreservation.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, screening.SeatReservationsTable, screening.SeatReservationsColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ScreeningClient) Hooks() []Hook {
	return c.hooks.Screening
}

// Interceptors returns the client interceptors.
func (c *ScreeningClient) Interceptors() []Interceptor {
	return c.inters.Screening
}

func (c *ScreeningClient) mutate(ctx context.Context, m *ScreeningMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ScreeningCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ScreeningUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ScreeningUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ScreeningDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Screening mutation op: %q", m.Op())
	}
}

// SeatClient is a client for the Seat schema.
type SeatClient struct {
	config
}

// NewSeatClient returns a client for the Seat from the given config.
func NewSeatClient(c config) *SeatClient {
	return &SeatClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `seat.Hooks(f(g(h())))`.
func (c *SeatClient) Use(hooks ...Hook) {
	c.hooks.Seat = append(c.hooks.Seat, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `seat.Intercept(f(g(h())))`.
func (c *SeatClient) Intercept(interceptors ...Interceptor) {
	c.inters.Seat = append(c.inters.Seat, interceptors...)
}

// Create returns a builder for creating a Seat entity.
func (c *SeatClient) Create() *SeatCreate {
	mutation := newSeatMutation(c.config, OpCreate)
	return &SeatCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Seat entities.
func (c *SeatClient) CreateBulk(builders ...*SeatCreate) *SeatCreateBulk {
	return &SeatCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SeatClient) MapCreateBulk(slice any, setFunc func(*SeatCreate, int)) *SeatCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SeatCreateBulk{err: fmt.Errorf("calling to SeatClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SeatCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SeatCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Seat.
func (c *SeatClient) Update() *SeatUpdate {
	mutation := newSeatMutation(c.config, OpUpdate)
	return &SeatUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SeatClient) UpdateOne(s *Seat) *SeatUpdateOne {
	mutation := newSeatMutation(c.config, OpUpdateOne, withSeat(s))
	return &SeatUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SeatClient) UpdateOneID(id int64) *SeatUpdateOne {
	mutation := newSeatMutation(c.config, OpUpdateOne, withSeatID(id))
	return &SeatUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Seat.
func (c *SeatClient) Delete() *SeatDelete {
	mutation := newSeatMutation(c.config, OpDelete)
	return &SeatDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SeatClient) DeleteOne(s *Seat) *SeatDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SeatClient) DeleteOneID(id int64) *SeatDeleteOne {
	builder := c.Delete().Where(seat.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SeatDeleteOne{builder}
}

// Query returns a query builder for Seat.
func (c *SeatClient) Query() *SeatQuery {
	return &SeatQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSeat},
		inters: c.Interceptors(),
	}
}

// Get returns a Seat entity by its id.
func (c *SeatClient) Get(ctx context.Context, id int64) (*Seat, error) {
	return c.Query().Where(seat.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SeatClient) GetX(ctx context.Context, id int64) *Seat {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCinema queries the cinema edge of a Seat.
func (c *SeatClient) QueryCinema(s *Seat) *CinemaQuery {
	query := (&CinemaClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(seat.Table, seat.FieldID, id),
			sqlgraph.To(cinema.Table, cinema.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, seat.CinemaTable, seat.CinemaColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySeatReservations queries the seat_reservations edge of a Seat.
func (c *SeatClient) QuerySeatReservations(s *Seat) *SeatReservationQuery {
	query := (&SeatReservationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(seat.Table, seat.FieldID, id),
			sqlgraph.To(seatreservation.Table, seatreservation.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, seat.SeatReservationsTable, seat.SeatReservationsColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SeatClient) Hooks() []Hook {
	return c.hooks.Seat
}

// Interceptors returns the client interceptors.
func (c *SeatClient) Interceptors() []Interceptor {
	return c.inters.Seat
}

func (c *SeatClient) mutate(ctx context.Context, m *SeatMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SeatCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SeatUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SeatUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SeatDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Seat mutation op: %q", m.Op())
	}
}

// SeatReservationClient is a client for the SeatReservation schema.
type SeatReservationClient struct {
	config
}

// NewSeatReservationClient returns a client for the SeatReservation from the given config.
func NewSeatReservationClient(c config) *SeatReservationClient {
	return &SeatReservationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `seatreservation.Hooks(f(g(h())))`.
func (c *SeatReservationClient) Use(hooks ...Hook) {
	c.hooks.SeatReservation = append(c.hooks.SeatReservation, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `seatreservation.Intercept(f(g(h())))`.
func (c *SeatReservationClient) Intercept(interceptors ...Interceptor) {
	c.inters.SeatReservation = append(c.inters.SeatReservation, interceptors...)
}

// Create returns a builder for creating a SeatReservation entity.
func (c *SeatReservationClient) Create() *SeatReservationCreate {
	mutation := newSeatReservationMutation(c.config, OpCreate)
	return &SeatReservationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SeatReservation entities.
func (c *SeatReservationClient) CreateBulk(builders ...*SeatReservationCreate) *SeatReservationCreateBulk {
	return &SeatReservationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SeatReservationClient) MapCreateBulk(slice any, setFunc func(*SeatReservationCreate, int)) *SeatReservationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SeatReservationCreateBulk{err: fmt.Errorf("calling to SeatReservationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SeatReservationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SeatReservationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SeatReservation.
func (c *SeatReservationClient) Update() *SeatReservationUpdate {
	mutation := newSeatReservationMutation(c.config, OpUpdate)
	return &SeatReservationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SeatReservationClient) UpdateOne(sr *SeatReservation) *SeatReservationUpdateOne {
	mutation := newSeatReservationMutation(c.config, OpUpdateOne, withSeatReservation(sr))
	return &SeatReservationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SeatReservationClient) UpdateOneID(id int64) *SeatReservationUpdateOne {
	mutation := newSeatReservationMutation(c.config, OpUpdateOne, withSeatReservationID(id))
	return &SeatReservationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SeatReservation.
func (c *SeatReservationClient) Delete() *SeatReservationDelete {
	mutation := newSeatReservationMutation(c.config, OpDelete)
	return &SeatReservationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SeatReservationClient) DeleteOne(sr *SeatReservation) *SeatReservationDeleteOne {
	return c.DeleteOneID(sr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SeatReservationClient) DeleteOneID(id int64) *SeatReservationDeleteOne {
	builder := c.Delete().Where(seatreservation.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SeatReservationDeleteOne{builder}
}

// Query returns a query builder for SeatReservation.
func (c *SeatReservationClient) Query() *SeatReservationQuery {
	return &SeatReservationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSeatReservation},
		inters: c.Interceptors(),
	}
}

// Get returns a SeatReservation entity by its id.
func (c *SeatReservationClient) Get(ctx context.Context, id int64) (*SeatReservation, error) {
	return c.Query().Where(seatreservation.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SeatReservationClient) GetX(ctx context.Context, id int64) *SeatReservation {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySeat queries the seat edge of a SeatReservation.
func (c *SeatReservationClient) QuerySeat(sr *SeatReservation) *SeatQuery {
	query := (&SeatClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(seatreservation.Table, seatreservation.FieldID, id),
			sqlgraph.To(seat.Table, seat.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, seatreservation.SeatTable, seatreservation.SeatColumn),
		)
		fromV = sqlgraph.Neighbors(sr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryScreening queries the screening edge of a SeatReservation.
func (c *SeatReservationClient) QueryScreening(sr *SeatReservation) *ScreeningQuery {
	query := (&ScreeningClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(seatreservation.Table, seatreservation.FieldID, id),
			sqlgraph.To(screening.Table, screening.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, seatreservation.ScreeningTable, seatreservation.ScreeningColumn),
		)
		fromV = sqlgraph.Neighbors(sr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SeatReservationClient) Hooks() []Hook {
	return c.hooks.SeatReservation
}

// Interceptors returns the client interceptors.
func (c *SeatReservationClient) Interceptors() []Interceptor {
	return c.inters.SeatReservation
}

func (c *SeatReservationClient) mutate(ctx context.Context, m *SeatReservationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SeatReservationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SeatReservationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SeatReservationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SeatReservationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SeatReservation mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		Cinema, Movie, Screening, Seat, SeatReservation []ent.Hook
	}
	inters struct {
		Cinema, Movie, Screening, Seat, SeatReservation []ent.Interceptor
	}
)
